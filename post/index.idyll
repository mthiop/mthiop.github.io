[meta title:"Potential Fields" description:"Pfadplanung mit Potential Fields" /]


[Header
  title:"Pfadplanung mit Potential Fields"
  subtitle:""
  author:"" /]

[Aside]
//[CustomD3Component className:"d3-component" rep_factor:20 attr_factor:20 state:0 step_size:10 influence_range:100 movable_objects:0 /]
[image style:`{width: '100%'}` src:"/static/images/screenshot.png" /]
[/Aside]


## Abstract

Diese Seite ist im Rahmen des Kurses **Data Visualization** an der Freien
Universität Berlin entstanden. Aufgabe war es einen Algorithmus zu erklären und
zu visualisieren, wobei Informatikstudenten im ersten Semester für das
Studium motiviert werden sollten.

Die Pfadplanung mit Potentialfelder kommt aus der Robotik. und dient einem Roboter mit Hilfe von Potentialfelder einen Weg zu einem Ziel zu finden, ohne Kollidierung mit einem Hinderniss.


## Problembeschreibung

Stell dir vor, ein Roboter (hier R2D2) soll von seinem Startpunkt aus ein Ziel erreichen.
Auf dem Weg des Roboters liegen jedoch Hindernisse. Gefährliche Kampfdruiden und gemeine Bösewichte wollen den Roboter aufhalten. Daher muss der Roboter einen Weg zum Ziel finden, ohne an eines der Hindernisse zu geraten.

Damit der Roboter so wenig Energie wie möglich verbraucht, muss er einen möglichst
kurzen Weg finden. Hier für wird die Pfadplanung, hier mit
der *Potential Fields Methode* eingesetzt.

Bei dieser Methode werden einfache physikalische Kräfte verwendet.

Diese berechneten Kräfte bzw. Potentiale weisen den Roboter in eine Richtung. Das Ziel
zieht den Roboter an und die Hindernisse stoßen ihn ab. Dadurch sollen Begegnungen mit den Hindernissen vermieden werden.

## Der Algorithmus



Der Algorithmus Potential Fields nutzt einfache physikalische Elemente zur Wegfindung
zum Ziel und Vermeidung von Kollision mit einem Hindernis. Das Ziel hat anziehende Kräfte, daher
wird der Roboter dorthin gezogen. Die Hindernisse umgeht der Roboter, da diese
abstoßende Kräfte haben.

In dieser Animation (rechts) kannst du die Posiiton des Roboters (grüner Kreis),
die Hindernisse (Dreiecke) und das Ziel (roter Kreis) ändern und sehen, wie
sich der Roboter verhält. Leuchtet ein Hindernis rot beeinflusst es den Roboter


## Erklärung

[Aside]
[var name:"state" value: 0 /]
[CustomD3Component className:"d3-component" rep_factor:rep_factor attr_factor:attr_factor state:state2 step_size:step_size influence_range:influence_range movable_objects:0 /]
//[CustomD3Component className:"d3-component" rep_factor:20 attr_factor:20 state:state step_size:10 influence_range:100 movable_objects:1 /]
[button onClick:`state++`]
Toggle Animation
[/button]
[/Aside]

Wie findet der Roboter den Weg zum Ziel ohne mit Hindernissen zu kollidieren?
Der Roboter wird durch eine Kraft [Equation] F [/Equation] beeinflusst.
Im Bild rechts sieht man einen zweidimensionalen Raum mit allen anfahrbaren Positionen
des Roboters. Die Position des Roboters [Equation]q_r[/Equation], bestehend aus
einer x- und einer y- Koordinate, berechnet sich durch folgende Gleichung:

[Equation]q_r=\sigma * \frac{F(q_r)}{|F(q_r)|}[/Equation]


Dabei bezeichnet [Equation]\sigma [/Equation] die Schrittlänge des Roboters.
Also kann mit diesem Paramter Einfluss auf die Entfernung, die der Roboter in
einem Planungszyklus durchläuft, genommen werden.

Wenn du den Regler verschiebst, kannst du die Schrittgröße beeinflussen.
Fällt dir ein Problem auf, wenn du den Wert sehr hoch setzt?

Schrittgröße:
[var name:"step_size" value:10 /]
[Dynamic value: step_size min:0 max:100 step:1 /]

[Range value: step_size min:0 max:100 /]


Wie du vielleicht bemerkt hast, springt der Roboter durch Hindernisse und
überspringt gegegenfalls das Ziel. Das liegt daran, dass der Roboter während
eines Schrittes immer in die gleiche Richtung geht.

Schauen wir uns nun an wie die Richtung bestimmt wird:


[Equation]F(q_r)=F_{\text{anziehend}}(q_r)+F_{\text{abstoßend}}(q_r)[/Equation].

Dabei ist [Equation]F_{\text{anziehend}}[/Equation] die anziehende Kraft des
Roboters in die Richtung des Ziels. Das Ziel [Equation]q_z[/Equation], das der
Roboter erreichen soll, strahlt diese Kraft aus.

Verschiebe
Eine Variante diese zu berechnen
nennt man konisch:

[Equation]F_{\text{anziehend}}(q_r)= -\epsilon * \frac{qr-qz}{|qr-qz|}[/Equation]

Es wird ein Vektor in Richtung des Ziels bestimmt und gewichtet.
Der Parameter \epsilon verstärkt die anziehende Kraft oder schwächt sie ab.
Da mit der Kraft [Equation]F_{\text{anziehend}}[/Equation] der Roboter auf seinem
Weg alle Hindernisse ignorieren würde, geht von den Hindernissen eine Abstoßungskraft
 [Equation]F_{\text{abstoßend}}(q_r)[/Equation] aus.

Mit Verschiebung des Regelers ändert sich die Anziehungskraft des Ziels zum Roboter.

 Anziehungskraft:
[var name:"attr_factor" value: 5 /]
[Dynamic value: attr_factor min:0 max:10 step:0.1 /]

[Range value: attr_factor min:0 max:10  /]


 TODO:


[Equation]F_{\text{abstoßend}}(q_r)=\theta * F_{\text{Erkennung}} * F_{\text{Entfernung}} * \frac{qr-qz}{|qr-qz|}[/Equation]


[Equation]F_{\text{abstoßend}}=(\frac{1}{|p(q_r)|} - \frac{1}{\phi})[/Equation]


[Equation]F_{\text{Entfernung}}= \frac{1}{p(q_r)^2}[/Equation]


Damit der Roboter zum Ziel kommt,aber nicht mit möglichen Hinernissen kollidiert,
geht von den Hindernissen die Kraft [Equation]F_{\text{abstoßend}}[/Equation] ab.



Probiere einfach mit den folgenden Reglern aus, wie die einzelnen Paramter
den Roboter, in der Darstellung rechts, beeinflussen.


[Aside]
[var name:"state2" value: 0 /]
//[CustomD3Component className:"d3-component" rep_factor:rep_factor attr_factor:attr_factor state:state2 step_size:step_size influence_range:influence_range movable_objects:0 /]

//[Display value:clickCount /]
[CustomPlot rep_factor:rep_factor attr_factor:attr_factor influence_range:influence_range steps:steps /]
[button onClick:`state2++`]
Toggle Animation
[/button]
[/Aside].

Steps:

[var name:steps value:50 /]
[Range value:steps min:1 max:100 /]



Abstoßungskraft:
[var name:"rep_factor" value:20 /]
[Dynamic value: rep_factor min:0 max:100 step: 1/]

[Range value: rep_factor min:0 max:100 /]

Hindernisseinflussbereich:
[var name:"influence_range" value:50 /]
[Dynamic value: influence_range min:1 max:100 step:1/]

[Range value: influence_range min:1 max:100 /]



Falls dein Interesse geweckt ist, gibt es hier noch etwas mehr [link text:"Informationen" url:"http://portal.ku.edu.tr/~cbasdogan/Courses/Robotics/projects/algorithm_poten_field.pdf" /]. Dort wird noch auf die Probleme des Algorithmus und Erweiterungen eingegangen.
