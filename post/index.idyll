[meta title:"Potential Fields" description:"Pfadplanung mit Potential Fields" /]


[Header
  title:"Pfadplanung mit Potential Fields"
  subtitle:""
  author:"" /]

// Variables
[var name:"state" value: 0 /]
[var name:"step_size" value:10/]
[var name:"attr_factor" value: 20 /]
[var name:"rep_factor" value:20 /]
[var name:"influence_range" value:100 /]
[var name:"state2" value: 0 /]
[var name:steps value:50 /]
[var name:"playgroundVisible" value:1 /]
[var name:"forceViz" value:0 /]

[div onExitView:`playgroundVisible = 0` onEnterViewFully:`playgroundVisible = 1`]
[Fixed]
[div id:"forceViz"]
//[Conditional if:`forceViz == 1`]
[Graphic]
     [img height:450 width:450 src:`"static/images/staticPlayground.png"` /]
[/Graphic]
//[/Conditional]
//[DebugComponent rep_factor:rep_factor attr_factor:attr_factor influence_range:influence_range steps:steps /]
[/div]
[/Fixed]
[Fixed]
[CustomD3Component className:"d3-component" rep_factor:20 attr_factor:20 state:state step_size:10 influence_range:100 movable_objects:1 visible:playgroundVisible /]
//[button onClick:`state++`]
//Play/Pause
//[/button]
[/Fixed]

## Abstract

Diese Seite ist im Rahmen des Kurses **Data Visualization** an der Freien
Universität Berlin entstanden. Aufgabe war es einen Algorithmus zu erklären und
zu visualisieren, wobei Informatikstudenten im ersten Semester für das
Studium motiviert werden sollten.

Die Pfadplanung mit Potentialfelder ist ein Algorithmus aus der Robotik und dient dazu einem Roboter einen Weg zu einem Ziel zu planen, ohne mit einem Hinderniss zu kollidieren.


## Problembeschreibung

Stell dir vor, ein Roboter (hier R2D2) soll von seinem Startpunkt aus ein Ziel erreichen.
Auf dem Weg des Roboters liegen jedoch Hindernisse. Gefährliche Kampfdruiden und gemeine Bösewichte wollen den Roboter aufhalten. Daher muss der Roboter einen Weg zum Ziel finden, ohne an eines der Hindernisse zu geraten.

Damit der Roboter so wenig Energie wie möglich verbraucht, muss er einen möglichst
kurzen Weg finden. Hier für wird die Pfadplanung, hier mit
der *Potential Fields Methode* eingesetzt.

Bei dieser Methode werden einfache physikalische Kräfte verwendet.

Diese berechneten Kräfte bzw. Potentiale weisen den Roboter in eine Richtung. Das Ziel
zieht den Roboter an und die Hindernisse stoßen ihn ab. Dadurch sollen Begegnungen mit den Hindernissen vermieden werden.


## Der Algorithmus

Der Algorithmus Potential Fields nutzt einfache physikalische Elemente zur Wegfindung
zum Ziel und Vermeidung von Kollision mit einem Hindernis. Das Ziel hat anziehende Kräfte, daher
wird der Roboter dorthin gezogen. Die Hindernisse umgeht der Roboter, da diese
abstoßende Kräfte haben.

Auf der rechten Seite siehst du eine Simulation des Algorithmus. [action onClick:`state++`]Klicke hier, um die Simulation zu starten.[/action] Der blaumarkierte Roboter findet einen Weg zum orange markierten Ziel. Du kannst alle Objekte verschieben und an beliebiger Stelle [action onClick:`state++`]pausieren und fortsetzen[/action]. Nutze die Gelegenheit um erste Erfahrungen mit dem Algorithmus zu sammeln. Du kannst dir ein eigenes Szenario mit dem Roboter, den Hindernissen und dem Ziel zusammenbauen.


## Parametererklärung

Wie findet der Roboter den Weg zum Ziel ohne mit Hindernissen zu kollidieren?
Der Roboter wird durch eine Kraft [Equation] F [/Equation] beeinflusst.
Im Bild rechts sieht man einen zweidimensionalen Raum mit allen anfahrbaren Positionen des Roboters. Die Position des Roboters [Equation]q_r[/Equation], bestehend aus einer x- und einer y- Koordinate, berechnet sich durch folgende Gleichung:


[Equation]q_r=\sigma * \frac{F(q_r)}{|F(q_r)|}[/Equation]

Dabei bezeichnet [Equation]\sigma [/Equation] die Schrittlänge des Roboters.
Also kann mit diesem Paramter Einfluss auf die Entfernung, die der Roboter in
einem Planungszyklus durchläuft, genommen werden.

Wenn du den Regler [em]Schrittgröße[/em][Equation]\sigma[/Equation] verschiebst, kannst du die Schrittgröße beeinflussen.
Fällt dir ein Problem auf, wenn du den Wert sehr hoch setzt?

[/div]
[div ]



[p]
  [em]Schrittgröße [/em][Equation]\sigma[/Equation]
	[Range value: step_size min:6 max:100 /]
  [Display value:step_size /]
[/p]



Wie du vielleicht bemerkt hast, springt der Roboter durch Hindernisse und
überspringt gegegenfalls das Ziel. Das liegt daran, dass der Roboter während
eines Schrittes immer in die gleiche Richtung geht.

[br /]

Schauen wir uns nun an wie die Richtung bestimmt wird:

[Equation]F(q_r)=F_{\text{anziehend}}(q_r)+F_{\text{abstoßend}}(q_r,q_h)[/Equation]

[br /]
[br /]


[Equation]F(q_r)[/Equation] besteht aus zwei Komponenten. Zum einen ist
[Equation]F_{\text{anziehend}(q_r)}[/Equation] die anziehende Kraft des
Roboters in die Richtung des Ziels. Das Ziel hat dabei die Position
[Equation]q_z[/Equation].
Zum anderen beschreibt [Equation]F_{\text{abstoßend}(q_r, q_h)}[/Equation] die
abstoßende Kraft des nächsten Hindernisses. Das Hindernis hat dabei die Position [Equation]q_h[/Equation]. Es wird immer nur das Hindernis mit dem kleinsten Abstand zum Roboter betrachtet.


Die anziehende Kraft wird berechnet durch:

[Equation]F_{\text{anziehend}}(q_r)= -\epsilon *\frac{qr-qz}{|qr-qz|}[/Equation]

[br /]
[br /]


Du sieht, dass das Ergebnis nur vom Abstand des Roboters und des Ziels, sowie dem Skalierungsparameter [Equation]\epsilon[/Equation] abhängt.
Es wird ein Vektor in Richtung des Ziels bestimmt und gewichtet.
Der Parameter [Equation]\epsilon[/Equation] verstärkt die anziehende Kraft oder schwächt sie ab.

Diese anziehende Kraft kannst du dir auch wie einen Abhang vorstellen. Das Tal ist das Ziel und die Steigung die Anziehungskraft.

Mit Verschiebung des Regelers [em]Anziehungskraft [/em] ändert sich die Anziehungskraft des Ziels zum Roboter. Beobachte wie sich die Steigung und das Verhalten des Roboters verändert.

[p]
  [em]Anziehungskraft [/em] [Equation]\epsilon[/Equation]
	[Range value:attr_factor min:0 max:100 /]
  [Display value:attr_factor /]
[/p]

[DebugComponentAttr rep_factor:rep_factor attr_factor:attr_factor influence_range:influence_range steps:step_size /]

Damit der Roboter zum Ziel kommt, aber nicht mit möglichen Hinernissen kollidiert, geht von den Hindernissen die Kraft [Equation]F_{\text{abstoßend}}[/Equation] ab.

[Equation]F_{\text{abstoßend}}(q_r)=\theta * F_{\text{Erkennung}}*F_{\text{Entfernung}} *\frac{q_r-q_h}{|q_r-q_z|}[/Equation].


Hier stellt [Equation]\theta[/Equation] den Skalierungsparamter dar.

[br/]
[Equation]F_{\text{Entfernung}}=\frac{1}{p(q_r)^2}[/Equation]


//Formel F-Entfernung

[br /]
[br /]

[Equation]F_{\text{Entfernung}}[/Equation] repräsentiert den Abstand zwischen Roboter und Hindernis:


[Equation]F_{\text{Erkennung}}=(\frac{1}{q_r}-\frac{1}{\phi})[/Equation]

[br /]
[br /]

[Equation]F_{\text{Erkennung}}[/Equation]regelt den Einfluss eines Hindernisses auf den Roboter. Erst wenn der Abstand zwischen Roboter und Hinderniss kleiner als phi ist, wird [Equation]F_{\text{abstoßend}}[/Equation]berechnet. Ist der Abstand kleiner als [Equation]\phi[/Equation] , wird F-Erkennung größer, je kleiner der Abstand zwischen Roboter und Hindernis ist. In der Simulation wird ein Hindernis rot markiert, wenn [Equation]\phi[/Equation] kleiner als der Abstand ist.

Ein Hindernis hat neben der abstoßenden Kraft auch einen Einflussbereich, der beeinflusst wann der Roboter durch die abstoßende Kraft beeinflusst wird.

Ähnlich wie mit unserem Abhang für die anziehende Kraft, kannst du dir ein Hindernis als Berg auf einer Ebene vorstellen. Dabei ist die abstoßende Kraft die Steigung und der Einflussbereich die Breite des Berges.

Verschiebe die Regler [em]Abstoßungskraft[/em] und [em]Hindernisseinflussbereich[/em]. Beobachte wie sich die Steigung und die Breite des Berges ändern und wie sich der Roboter zu den Hindernissen verhält.

[DebugComponentRep rep_factor:rep_factor attr_factor:attr_factor influence_range:influence_range steps:step_size /]

[p]
  [em]Abstoßungskraft [/em][Equation]\theta[/Equation]
	[Range value:rep_factor min:0 max:100 /]
  [Display value:rep_factor /]
[/p]

[p]
  [em]Hindernisseinflussbereich[/em] [Equation]\phi[/Equation]
	[Range value:influence_range min:0 max:400 /]
  [Display value:influence_range/]
[/p]

[DebugComponentRep rep_factor:rep_factor attr_factor:attr_factor influence_range:influence_range steps:step_size /]



Die Addition der anziehenden Kraft (Abhang) mit der abstoßenden Kraft (Berg) ergibt das Potentialfeld:

[DebugComponent rep_factor:rep_factor attr_factor:attr_factor influence_range:influence_range steps:step_size /]

[/div]
[div onExitViewFully:`forceViz=1;playgroundVisible=0;` onEnterViewFully:`forceViz=0;playgroundVisible=1;`]

### Parameteranwendung
[p]
  [em]Schrittgröße [/em][Equation]\sigma[/Equation]
	[Range value: step_size min:6 max:100 /]
  [Display value:step_size /]
[/p]

[p]
  [em]Anziehungskraft [/em] [Equation]\epsilon[/Equation]
	[Range value:attr_factor min:0 max:100 /]
  [Display value:attr_factor /]
[/p]

[p]
  [em]Abstoßungskraft [/em][Equation]\theta[/Equation]
	[Range value:rep_factor min:0 max:100 /]
  [Display value:rep_factor /]
[/p]

[p]
  [em]Hindernisseinflussbereich[/em] [Equation]\phi[/Equation]
	[Range value:influence_range min:0 max:400 /]
  [Display value:influence_range/]
[/p]



Falls dein Interesse geweckt ist, gibt es hier noch etwas mehr [link text:"Informationen" url:"http://portal.ku.edu.tr/~cbasdogan/Courses/Robotics/projects/algorithm_poten_field.pdf" /]. Dort wird noch auf die Probleme des Algorithmus und Erweiterungen eingegangen.

[/div]
